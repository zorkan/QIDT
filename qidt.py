# -*- coding: utf-8 -*-
"""QIDT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-4FY4JR2qNKUnHFgA6LIIW51lgkIkdIC
"""

class QuantumImageProcessor:
    def __init__(self, original_image):
        self.original_image = original_image
        self.flatten_image = np.array(original_image).flatten()
        self.image_angles = self.get_deviation(self.original_image)
        self.simulator = AerSimulator()
        self.new_matrix = self.process_images()[0]
        self.result_rx_circuit = self.process_images()[1]
        self.result_rx_matrix = np.zeros((28, 28))

    def get_deviation(self, image):
        flatten_image = np.array(image).flatten()
        set_number = int(len(flatten_image) / 4)
        dev_list = []
        for i in range(set_number):
            dev_list.append(statistics.stdev(flatten_image[i * 4:i * 4 + 4]))
        return dev_list

    def create_rx_circuit(self):
        qc_rx = QuantumCircuit(4, 4, name='rx_circuit')
        qc_rx.h(0)
        qc_rx.h(1)
        qc_rx.h(2)
        qc_rx.h(3)
        qc_rx.rx(self.image_angles[0], 0)
        qc_rx.rx(self.image_angles[1], 1)
        qc_rx.rx(self.image_angles[2], 2)
        qc_rx.rx(self.image_angles[3], 3)
        qc_rx.barrier()
        qc_rx.cx(0, 1)
        qc_rx.cx(1, 2)
        qc_rx.cx(2, 3)
        qc_rx.barrier()
        qc_rx.measure([0, 1, 2, 3], [0, 1, 2, 3])
        return qc_rx

    def create_ry_circuit(self):
        qc_ry = QuantumCircuit(4, 4, name='ry_circuit')
        qc_ry.h(0)
        qc_ry.h(1)
        qc_ry.h(2)
        qc_ry.h(3)
        qc_ry.ry(self.image_angles[0], 0)
        qc_ry.ry(self.image_angles[1], 1)
        qc_ry.ry(self.image_angles[2], 2)
        qc_ry.ry(self.image_angles[3], 3)
        qc_ry.barrier()
        qc_ry.cx(0, 1)
        qc_ry.cx(1, 2)
        qc_ry.cx(2, 3)
        qc_ry.barrier()
        qc_ry.measure([0, 1, 2, 3], [0, 1, 2, 3])
        return qc_ry

    def create_rz_circuit(self):
        qc_rz = QuantumCircuit(4, 4, name='rz_circuit')
        qc_rz.h(0)
        qc_rz.h(1)
        qc_rz.h(2)
        qc_rz.h(3)
        qc_rz.rz(self.image_angles[0], 0)
        qc_rz.rz(self.image_angles[1], 1)
        qc_rz.rz(self.image_angles[2], 2)
        qc_rz.rz(self.image_angles[3], 3)
        qc_rz.barrier()
        qc_rz.cx(0, 1)
        qc_rz.cx(1, 2)
        qc_rz.cx(2, 3)
        qc_rz.barrier()
        qc_rz.measure([0, 1, 2, 3], [0, 1, 2, 3])
        return qc_rz

    def get_image_matrix(self, circuit):
        image_matrix = []
        main_circuit = QuantumCircuit(4, 4)
        main_circuit.append(circuit.to_instruction(), [0, 1, 2, 3], [0, 1, 2, 3])
        main_circuit.measure([0, 1, 2, 3], [0, 1, 2, 3])
        main_circuit = main_circuit.decompose()

        job = self.simulator.run(transpile(main_circuit, self.simulator), shots=1024)
        result = job.result()
        counts = result.get_counts()

        sorted_data = OrderedDict(sorted(counts.items()))
        for i, j in enumerate(sorted_data.items()):
            image_matrix.append(j[1] * self.flatten_image[i % len(self.flatten_image)])

        while len(image_matrix) < len(self.flatten_image):
            image_matrix.append(0)

        image_matrix = image_matrix[:len(self.flatten_image)]

        return np.array(image_matrix).reshape(self.original_image.shape),main_circuit

    def process_images(self):
        rx_matrix = self.get_image_matrix(self.create_rx_circuit())
        ry_matrix = self.get_image_matrix(self.create_ry_circuit())
        rz_matrix = self.get_image_matrix(self.create_rz_circuit())
        con = np.sum(rx_matrix[0] + ry_matrix[0] + rz_matrix[0]) / 255
        sum_matrix = ((rx_matrix[0] + rz_matrix[0]) * con) - ry_matrix[0]

        new_matrix = []
        for i in sum_matrix:
            for j in i:
                if j > 255:
                    new_matrix.append(255)
                else:
                    new_matrix.append(j)

        new_matrix = np.reshape(new_matrix, self.original_image.shape)
        self.result_rx_matrix = rx_matrix[0]
        plt.figure(figsize = (2,2))
        plt.imshow(self.result_rx_matrix)
        plt.axis(False);
        self.result_rx_circuit = rx_matrix[1]
        return new_matrix, 1.0

    def show_plot(self):
        plt.figure(figsize=(10, 7))
        plt.subplot(1, 2, 1)
        plt.title('Original')
        plt.imshow(self.original_image, cmap='gray')
        plt.subplot(1, 2, 2)
        plt.title('Result')
        plt.imshow(self.new_matrix, cmap='gray')
        plt.show()

    def get_circuit_data(self):
      print(self.result_rx_circuit)
      print(self.result_rx_circuit)
      self.result_rx_circuit.draw('mpl')
      return self.result_rx_circuit

    def get_image_data(self):
        return self.new_matrix

class QuantumImageSplitter:
    def __init__(self, original_image):
        self.original_image = original_image.reshape(28,28)
        self.combined_image, self.combined_circuit = self.divide_and_process()

    def process_submatrix(self, submatrix):
        processor = QuantumImageProcessor(submatrix)
        circu = processor.get_circuit_data()
        return processor.process_images()[0], processor.get_circuit_data()

    def divide_and_process(self):
        rows, cols = self.original_image.shape
        submatrices = [self.original_image[i:i+4, j:j+4] for i in range(0, rows, 4) for j in range(0, cols, 4)]
        processed_submatrices = [self.process_submatrix(submatrix) for submatrix in submatrices]
        self.combined_image = self.combine_submatrices(processed_submatrices[0], rows, cols)
        return self.combined_image, processed_submatrices[1]

    def combine_submatrices(self, submatrices, rows, cols):

        combined_image = np.zeros((rows, cols))
        submatrix_size = submatrices[0].shape[0]
        for idx, submatrix in enumerate(submatrices):
            row = (idx // (cols // submatrix_size)) * submatrix_size
            col = (idx % (cols // submatrix_size)) * submatrix_size
            combined_image[row:row + submatrix_size, col:col + submatrix_size] = submatrix
        return combined_image

    def show_plot(self):
        plt.figure(figsize=(12, 4))
        plt.subplot(1, 2, 1)
        plt.title('Original Image')
        plt.imshow(self.original_image, cmap='gray')
        plt.subplot(1, 2, 2)
        plt.title('Processed Image')
        plt.imshow(self.combined_image, cmap='gray')
        plt.show()

    def get_circ(self):
        return self.combined_circuit

    def get_image_data(self):
        return self.combined_image